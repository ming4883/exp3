<!DOCTYPE html>
<html lang="en">
<head>
    <title>exp3 - demo_derivative_maps</title>
    <meta charset="utf-8">
</head>
<body>
    <div class="exp3.info">
    Parallax Occlusion Maps without Tangent Space, more info can be found <a class="exp3.link" href="http://km-on-rails.blogspot.hk/2013/07/parallax-occlusion-mapping-without.html">here</a>.
<pre>
Controls:
- Rotate : Mouse Left Button
- Zoom   : Mouse Right Button
</pre>
    </div>

    <script src="./js/three.min.js"></script>
    <script src="./js/stats.min.js"></script>
    <script src="./js/exp3.js"></script>
    <script src="./js/dat.gui.min.js"></script>
    <script src="./js/OBJLoader.js"></script>
    <script>

var config;
var meshes = [];
var material;
var textures = [];

function Config()
{
    var thiz = this;
    this.tile = 2.0;
    this.bumpness = 4.0;
    this.parallaxHeight = 4.0;
    this.occlusion = 0.5;
    this.parallax = true;
    this.silhouette = false;
    this.specular = true;
    this.debug = false;
    this.texture = 0;
    this.mesh = 0;
    
    this.texPaths = [ "./assets/brick_grad.png", "./assets/pyramids_grad.png", "./assets/stones_grad.png" ];
    this.geoPaths = [ "./assets/box.obj", "./assets/cylinder.obj", "./assets/torus.obj" ];
    //this.texNames = a_to_m( ["brick", "pyramids", "stones"] );
    //this.geoNames = a_to_m( ["box", "cylinder", "torus"] );
    
    this.shaderBumpness = function() { return ( this.bumpness / 64.0 ) * textures[this.texture].image.width; };
    this.shaderParallaxHeight = function() { return this.parallaxHeight / 8.0; };
    this.shaderParallaxSampleCount = function() { return this.parallaxHeight * 4.0; };
    
    function getfilename( x ) { return x.split(/(\\|\/)/g).pop(); }
    function a_to_m( a, f ) {
        var m = {};
        if ( f ) {
            for ( var i = 0; i < a.length; ++i )
                m[ f( a[i] ) ] = i;
        }
        else {
            for ( var i = 0; i < a.length; ++i )
                m[ a[i] ] = i;
        }
        return m;
    }
    
    var gui = new dat.GUI();
    
    var f;
    
    f = gui.addFolder( "Scene" )
    f.add( this, "mesh", a_to_m( this.geoPaths, getfilename ) )
        .onFinishChange( function( val ) { 
            for ( var i = 0; i < meshes.length; ++i ) {
                var vis = ( i == val );
                meshes[i].traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh )
                        child.visible = vis;
                } );
            }
        } );
    
    f.open();
    
    f = gui.addFolder( "Texture" );
    f.add( this, "texture", a_to_m( this.texPaths, getfilename ) )
        .onFinishChange( function( val ) { 
            material.uniforms.heightMap.value = textures[val];
        } );
    
    f.add( this, "tile", 1.0, 4.0 ).step( 1.0 );
    
    f.open();
    
    f = gui.addFolder( "D-POM" );
    f.add( this, "bumpness", 1.0, 8.0 ).step( 0.5 );
    f.add( this, "parallaxHeight", 2.0, 8.0 ).step( 1.0 );
    f.add( this, "occlusion", 0.0, 1.0 ).step( 0.125 );
    
    f.add( this, "parallax" )
        .onChange( function( val ) { material.uniforms.useParallax.value = val ? 1.0 : 0.0; } );
    f.add( this, "silhouette" )
        .onChange( function( val ) { material.uniforms.useSilhouette.value = val ? 1.0 : 0.0; } );
    f.add( this, "specular" )
        .onChange( function( val ) { material.uniforms.useSpecular.value = val ? 1.0 : 0.0; } );
    f.add( this, "debug" )
        .onChange( function( val ) { material.uniforms.debug.value = val ? 1.0 : 0.0; } );
    
    f.open();

}

function on_init( )
{
    config = new Config();
    
    this.enableStats();
    
    this.renderer.context.getExtension( "OES_standard_derivatives" );
    
    this.defaults.camera.position.set( 0.0, 0.0, 20.0 );
    
    // load textures
    for ( var i = 0; i < config.texPaths.length; ++i )
    {
        var tex = THREE.ImageUtils.loadTexture( config.texPaths[i] );
        tex.anisotropy = this.renderer.getMaxAnisotropy();
        tex.minFilter = tex.magFilter = THREE.LinearFilter;
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        textures.push( tex );
    }
    
    // load shaders and initialize material
    material = new THREE.ShaderMaterial( {
        uniforms : { 
            heightMap: { type: "t", value: textures[0] },
            tile : { type: "f", value: config.tile },
            bumpness : { type: "f", value: config.shaderBumpness() },
            parallaxHeight : { type: "f", value: config.shaderParallaxHeight() },
            occlusion : { type: "f", value: config.occlusion },
            parallaxSampleCount : { type: "f", value: config.shaderParallaxSampleCount() },
            useParallax : { type: "f", value: config.parallax ? 1.0 : 0.0 },
            useSilhouette : { type: "f", value: config.silhouette ? 1.0 : 0.0 },
            useSpecular : { type: "f", value: config.specular ? 1.0 : 0.0 },
            debug : { type: "f", value: config.debug ? 1.0 : 0.0 },
            camPos : { type: "v3", value: this.defaults.camera.position },
        },
        vertexShader   : this.loadText( "./assets/derivativemaps.vs" ),
        fragmentShader : this.loadText( "./assets/derivativemaps.fs" ),
        } );
    
    // load meshes
    var theScene = this.defaults.scene;
    
    for ( var i = 0; i < config.geoPaths.length; ++i )
    {
        var loader = new THREE.OBJLoader();
        loader.addEventListener( 'load', function ( event ) {

            var object = event.content;

            object.traverse( function ( child ) {

                if ( child instanceof THREE.Mesh )
                {
                    child.material = material;
                    child.visible = ( meshes.length == 0 );
                }
            } );
            
            object.rotation.x = 0.524;
            object.rotation.y = 1.047;

            theScene.add( object );
            meshes.push( object );
        });
        loader.load( config.geoPaths[i] );
    }
}

function on_resize( width, height )
{
    this.defaults.camera.aspect = width / height;
    this.defaults.camera.updateProjectionMatrix();
}

function on_render( )
{
    material.uniforms.camPos.value =  this.defaults.camera.position;

    material.uniforms.tile.value = config.tile;
    material.uniforms.bumpness.value = config.shaderBumpness();
    material.uniforms.parallaxHeight.value = config.shaderParallaxHeight();
    material.uniforms.parallaxSampleCount.value = config.shaderParallaxSampleCount();
    material.uniforms.occlusion.value = config.occlusion;
    
    this.renderer.setClearColor( this.context.bgcolorObj.getHex(), 1.0 );
    this.renderer.clear( true, true, true );
    this.renderer.render( this.defaults.scene, this.defaults.camera );
}

var mouseState = {
    down : false,
    downX : 0,
    downY : 0,
    deltaX : 0,
    deltaY : 0,
    rotX : 0,
    rotY : 0,
    viewZ : 0,
    onmove : function( event )
    {
        this.deltaX = event.clientX - this.downX;
        this.deltaY = event.clientY - this.downY;
    }
};

function on_mousedown( event )
{
    mouseState.down = true;
    mouseState.downX = event.clientX;
    mouseState.downY = event.clientY;
    mouseState.rotX = meshes[0].rotation.x;
    mouseState.rotY = meshes[0].rotation.y;
    mouseState.viewZ = this.defaults.camera.position.z;
}

function on_mouseup( event )
{
    mouseState.down = false;
}

function on_mousemove( event )
{
    if ( mouseState.down )
    {
        mouseState.onmove( event );
        
        if ( event.button === 0 )
        {
            var rotX = mouseState.rotX + 0.01 * mouseState.deltaY;
            var rotY = mouseState.rotY + 0.01 * mouseState.deltaX;
            var HALF_PI = 1.571;
            
            if ( rotX >  HALF_PI ) rotX =  HALF_PI;
            if ( rotX < -HALF_PI ) rotX = -HALF_PI;
            
            for ( var i = 0; i < meshes.length; ++i )
            {
                meshes[i].rotation.x = rotX;
                meshes[i].rotation.y = rotY;
            }
        }
        else if ( event.button === 2 )
        {
            var viewZ =  mouseState.viewZ + 0.5 * mouseState.deltaY;
            if ( viewZ < 10 ) viewZ = 10;
            if ( viewZ > 50 ) viewZ = 50;
            this.defaults.camera.position.z = viewZ;
        }
    }
}

// entry point
new Exp3( {
    bgcolor : "#202020",
    on_init : on_init, 
    on_resize : on_resize, 
    on_render : on_render,
    on_mousedown : on_mousedown,
    on_mouseup : on_mouseup,
    on_mousemove : on_mousemove,
    } );

    </script>

</body>
</html>
